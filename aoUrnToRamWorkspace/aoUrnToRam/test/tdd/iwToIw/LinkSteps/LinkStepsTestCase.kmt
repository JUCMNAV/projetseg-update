package aoUrnToRam::Test;

require kermeta
//stle: factory is common to IwToIw and IwToRam
require "platform:/resource/aoUrnToRam/test/tdd/iw/IwTestFactory.kmt"
require "platform:/resource/aoUrnToRam/src/iwToIw/LinkSteps/_Ref.kmt"

using kermeta::standard
using kermeta::kunit
using intermediateWorkflow

using kermeta::language::structure

class LinkStepsTestCase inherits TestCase
{
	reference factory:IwTestFactory
	reference concern:IwConcern
	reference workflow:IwWorkflow
	
	method setUp() is do
		factory:=IwTestFactory.new
		concern:= factory.createIwConcern
    	workflow:=factory.createIwWorkflow
    	concern.workflows.add(workflow)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_BoundStartPoint() is do
		var startPoint:IwStartPoint init factory.createIwStartPoint
		startPoint.startPointType:="bound"
		workflow.nodes.add(startPoint)
		var input:IwInput init factory.createIwInput
		workflow.nodes.add(input)
		factory.createIwNodeConnection(startPoint,input)
		
		startPoint.linkStep
		
		assert(concern.steps.size==0)
		assert(startPoint.step.isVoid)
		assert(input.step.isVoid)
	end
	
	operation testLinkStep_GlobalStartPoint() is do
		var startPoint:IwStartPoint init factory.createIwStartPoint
		startPoint.startPointType:="global"
		workflow.nodes.add(startPoint)
		var input:IwInput init factory.createIwInput
		workflow.nodes.add(input)
		factory.createIwNodeConnection(startPoint,input)
		
		startPoint.linkStep
		
		assertCollectionHasSingleElement(concern.steps,concern.steps.one)
		assert(startPoint.step==concern.steps.one)
		assert(input.step==concern.steps.one)
		assert(input.name==input.step.name)
	end

	operation testLinkStep_LocalStartPoint() is do
		var startPoint:IwStartPoint init factory.createIwStartPoint
		startPoint.startPointType:="local"
		workflow.nodes.add(startPoint)
		var input:IwInput init factory.createIwInput
		workflow.nodes.add(input)
		factory.createIwNodeConnection(startPoint,input)
		
		startPoint.linkStep
		
		assertCollectionHasSingleElement(concern.steps,concern.steps.one)
		assert(startPoint.step==concern.steps.one)
		assert(input.step==concern.steps.one)
		assert(input.name==input.step.name)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_CreateStep() is do
		var input:IwInput init factory.createIwInput
		workflow.nodes.add(input)
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)
		
		input.step_DeepFirstSearch(currentStep)

		var expectedSteps:Set<IwStep> init Set<IwStep>.new
		expectedSteps.add(currentStep)
		expectedSteps.add(input.step)
		assert(expectedSteps==concern.steps.asSet)
		assert(input.step.name==input.name)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_LinkStep() is do
		var node:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node)
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)

		node.step_DeepFirstSearch(currentStep)

		assert(node.step==currentStep)
		assertCollectionHasSingleElement(concern.steps,currentStep)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_CallNext() is do
		var node1:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node1)
		var node2:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node2)
		factory.createIwNodeConnection(node1,node2)
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)

		node1.step_DeepFirstSearch(currentStep)

		assert(node1.step==node2.step)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_CallNexts() is do
		var orFork:IwOrFork init factory.createIwOrFork
		workflow.nodes.add(orFork)
		var node1:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node1)
		factory.createIwNodeConnection(orFork,node1)
		var node2:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node2)
		factory.createIwNodeConnection(orFork,node2)
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)
		
		orFork.step_DeepFirstSearch(currentStep)

		assert(node1.step==currentStep)
		assert(node2.step==currentStep)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_AlreadyExplored_SameStep() is do
		var node1:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node1)
		var node2:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node2)
		factory.createIwNodeConnection(node1,node2)
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)
		node2.step:=currentStep
		
		node1.step_DeepFirstSearch(currentStep)
		
		assertObjectEqual(1,concern.steps.size)//No step added
		assertObjectEqual("theStep",currentStep.name)//No step merged
		assert(node1.step==node2.step)
	end

	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_AlreadyExplored_MergeStep() is do
		var node1:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node1)
		var node2:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node2)
		factory.createIwNodeConnection(node1,node2)
		var node3:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node3)
		factory.createIwNodeConnection(node2,node3)
		var toMerge:IwStep init factory.createIwStep
		concern.steps.add(toMerge)
		toMerge.name:="aSteptoMerge"
		node2.step:=toMerge
		node3.step:=toMerge
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)
		
		node1.step_DeepFirstSearch(currentStep)
		
		assertObjectEqual(1,concern.steps.size)//One step removed
		assertObjectEqual("aSteptoMerge_theStep",currentStep.name)//Step Merge + Name in alphabetical order
		assert(node1.step==node2.step)	//One node is merged
		assert(node1.step==node3.step)	//Many nodes are merged
	end
	
	@feature "FeaNamingOfRAMStep"
	operation testLinkStep_DeepFirstSearch_CallNexts_CreateStepInBetween() is do
		var orFork:IwOrFork init factory.createIwOrFork
		workflow.nodes.add(orFork)
		var node1:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node1)
		factory.createIwNodeConnection(orFork,node1)
		var input:IwInput init factory.createIwInput
		workflow.nodes.add(input)
		factory.createIwNodeConnection(orFork,input)
		var node2:IwCustomizableNode init factory.createIwCustomizableNode
		workflow.nodes.add(node2)
		factory.createIwNodeConnection(orFork,node2)
		var currentStep:IwStep init factory.createIwStep
		concern.steps.add(currentStep)
		
		orFork.step_DeepFirstSearch(currentStep)

		assert(node1.step==currentStep)
		assert(input.step!=currentStep)
		assert(node2.step==currentStep)
	end
		
	operation assertCollectionHasSingleElement<T>(collection:Collection<T>,singleElement:T) is do
		assertObjectEqual(1,collection.size)
		assert(collection.one==singleElement)
	end
	
	//stle: dry
	//stle: more verbrose on assertion
	operation assertIsNonVoidInstanceOf(expected:kermeta::language::structure::Class, actual:Object) is do
		assertWithMsg(actual.isVoid==false,"IsVoid-> expected:false actual:true")
		assertWithMsg(actual.isInstanceOf(expected),"IsInstanceOf-> expected:\""+expected.toString()+"\"actual:\""+actual.getMetaClass().toString()+"\"")
	end

	
	operation assertStringEqual(expected:String, actual:String) is do
		assertWithMsg(expected==actual,"StringEqual-> expected:\""+expected+"\"actual:\""+actual+"\"")
	end
	
	operation assertObjectEqual(expected:Object, actual:Object) is do
	//stle: check for void and type
		assertWithMsg(expected==actual,"ObjectEqual-> expected:\""+expected.toString+"\" actual:\""+actual.toString+"\"")
	end
}