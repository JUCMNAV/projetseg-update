package intermediateWorkflow;

require kermeta
require "platform:/resource/aoUrnToRam/metamodel/intermediateWorkflow.ecore"

using kermeta::standard
using kermeta::utils

aspect class IwModel {
	operation linkSteps() is do
		concerns.each{concern|concern.linkSteps}
	end
}

aspect class IwConcern {
	operation linkSteps() is do
		workflows.each{workflow|workflow.linkSteps(self)}
	end
}

aspect class IwWorkflow {
	operation linkSteps(concern:IwConcern) is do
		startPoints.each{node|node.linkStep}
	end
	
	property readonly concern:IwConcern
	getter is do
		result?=container
	end
}

aspect class IwNode {
	operation step_DeepFirstSearch(currentStep:IwStep) is do
		if(isUnexplored) then
			explore(currentStep)
		else
			if(isPartOfStep(currentStep)==false) then
				currentStep.merge(step)
			end
		end
	end

	//virtual
	operation explore(currentStep:IwStep) is do
		step:=currentStep
		succs.each{nodeConnection|exploreTargetOrStubEntry(nodeConnection)}
	end
	
	operation exploreTargetOrStubEntry(nodeConnection:IwNodeConnection) is do
		var stubTarget:IwStub
		stubTarget?=nodeConnection.target
		
		if(stubTarget.isVoid) then
			nodeConnection.target.step_DeepFirstSearch(step)
		else
			stubTarget.step_DeepFirstSearch_StubEntry(step,nodeConnection)
		end
	end
	
	operation isPartOfStep(currentStep:IwStep):Boolean is do
		result:=step==currentStep
	end
	
	property readonly isUnexplored : Boolean
	getter is do
		result:= step.isVoid
	end
	
	property readonly concern:IwConcern
	getter is do
		result:=workflow.concern
	end
}

aspect class IwStep {
	attribute _isPartiallyInitialized:Boolean
	
	operation flagAsPartiallyInitialized() is do
		_isPartiallyInitialized:=true
	end
	
	operation removeFlagAsPartiallyInitialized() is do
		_isPartiallyInitialized:=void 
	end
	
	property readonly isPartiallyInitialized : Boolean
	getter is do
		result:= _isPartiallyInitialized==true //Note that void!=true
	end

	operation merge(stepToMerge:IwStep) is do
		mergeName(stepToMerge)
		nodes.addAll(stepToMerge.nodes)
		concern.steps.remove(stepToMerge)
	end
	
	operation mergeName(stepToMerge:IwStep) is do
		if(name<stepToMerge.name) then
			name:=combineName(name,stepToMerge.name)
		else
			name:=combineName(stepToMerge.name,name)
		end
	end
	
	operation combineName(name1:String,name2:String):String is do
		result:=name1+"_"+name2
	end
}

aspect class IwStartPoint{
	operation linkStep() is do
		if(startPointType!=StartPointType.bound) then
			var currentStep:IwStep init IwStep.new
			currentStep.flagAsPartiallyInitialized
			concern.steps.add(currentStep)
			explore(currentStep)
		end
	end
}

aspect class IwInput {
	method explore(currentStep:IwStep) is do
		if(currentStep.isPartiallyInitialized) then
			currentStep.name:=name
			currentStep.removeFlagAsPartiallyInitialized
		else
			currentStep:=IwStep.new
			currentStep.name:=name
			concern.steps.add(currentStep)
		end
		super(currentStep)
	end
}

aspect class IwEndPoint
{
	method explore(currentStep:IwStep) is do
		super(currentStep)
		outBindings.each{outBinding|
			var stub:IwStub init outBinding.pluginBinding.stub
			stub.step_DeepFirstSearch_StubExit(currentStep,outBinding.stubExit)
		}
	end
}

aspect class IwStub{
	operation step_DeepFirstSearch_StubEntry(currentStep:IwStep, stubEntry:IwNodeConnection) is do
		//stle:Assume static stub must be bounded
		var staticPluginBinding:IwPluginBinding init pluginBindings.one 
		//stle:Assume stubEntry implies the existance of an inBinding
		//stle:Single again
		var pluginStartPoint:IwNode init staticPluginBinding.inBindings.select
										 {inBinding|inBinding.stubEntry==stubEntry}.one.pluginStartPoint
		
		if(concern==pluginStartPoint.concern) then
			setStep(currentStep)
			pluginStartPoint.step_DeepFirstSearch(step)
		else
			step_DeepFirstSearch(currentStep) //Consider stub as a normal node
		end
	end
	
	operation step_DeepFirstSearch_StubExit(currentStep:IwStep, stubExit:IwNodeConnection) is do
		setStep(currentStep)
		stubExit.target.step_DeepFirstSearch(step)
	end
	
	operation setStep(currentStep:IwStep) is do
		if(isUnexplored) then
			step:=currentStep
		else
			if(isPartOfStep(currentStep)==false) then
				currentStep.merge(step)
			end
		end
	end
}

