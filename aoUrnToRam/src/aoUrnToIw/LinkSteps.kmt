package intermediateWorkflow;

require kermeta
require "platform:/resource/aoUrnToRam/metamodel/intermediateWorkflow.ecore"

using kermeta::standard
using kermeta::utils

aspect class IwModel {
	operation linkSteps() is do
		concerns.each{concern|concern.linkSteps}
	end
}

aspect class IwConcern {
	operation linkSteps() is do
		workflows.each{workflow|workflow.linkSteps(self)}
	end
}

aspect class IwWorkflow {
	operation linkSteps(concern:IwConcern) is do
		startPoints.each{node|node.linkStep}
	end
	
	property readonly concern:IwConcern
	getter is do
		result?=container
	end
}

aspect class IwNode {
	operation step_DeepFirstSearch(currentStep:IwStep) is do
		if(isUnexplored) then
			explore(currentStep)
		else
			if(isPartOfStep(currentStep)==false) then
				currentStep.merge(step)
			end
		end
	end

	//virtual
	operation explore(currentStep:IwStep) is do
		step:=currentStep
		succs.each{nodeConnection|nodeConnection.target.step_DeepFirstSearch(step)}
	end
	
	operation isPartOfStep(currentStep:IwStep):Boolean is do
		result:=step==currentStep
	end
	
	property readonly isUnexplored : Boolean
	getter is do
		result:= step.isVoid
	end
	
	property readonly concern:IwConcern
	getter is do
		result:=workflow.concern
	end
}

aspect class IwStep {
	attribute _isPartiallyInitialized:Boolean
	
	operation flagAsPartiallyInitialized() is do
		_isPartiallyInitialized:=true
	end
	
	operation removeFlagAsPartiallyInitialized() is do
		_isPartiallyInitialized:=void 
	end
	
	property readonly isPartiallyInitialized : Boolean
	getter is do
		result:= _isPartiallyInitialized==true //Note that void!=true
	end

	operation merge(stepToMerge:IwStep) is do
		mergeName(stepToMerge)
		nodes.addAll(stepToMerge.nodes)
		stepToMerge.concern:=void
		
		stdio.writeln("merge step"+stepToMerge.name)
		stdio.writeln("num of concern"+concern.model.concerns.size.toString)
		stdio.writeln("num of step"+concern.steps.size.toString)
	end
	
	operation mergeName(stepToMerge:IwStep) is do
		if(name<stepToMerge.name) then
			name:=combineName(name,stepToMerge.name)
		else
			name:=combineName(stepToMerge.name,name)
		end
	end
	
	operation combineName(name1:String,name2:String):String is do
		result:=name1+"_"+name2
	end
}

aspect class IwStartPoint{
	operation linkStep() is do
		if(startPointType!="bound") then
			stdio.writeln("new partial step")
			var currentStep:IwStep init IwStep.new
			currentStep.flagAsPartiallyInitialized
			concern.steps.add(currentStep)
			explore(currentStep)
		end
	end
}

aspect class IwInput {
	method explore(currentStep:IwStep) is do
		if(currentStep.isPartiallyInitialized) then
			currentStep.name:=name
			currentStep.removeFlagAsPartiallyInitialized
			stdio.writeln("set partial step name:"+currentStep.name)
		else
			currentStep:=IwStep.new
			currentStep.name:=name
			concern.steps.add(currentStep)
			stdio.writeln("Create step:"+currentStep.name)
		end
		super(currentStep)
	end
}

aspect class IwEndPoint
{
	method explore(currentStep:IwStep) is do
		step:=currentStep
		outBindings.each{outBinding|
			currentStep.outboundStubs.add(outBinding.pluginBinding.stub)
			outBinding.stubExit.target.step_DeepFirstSearch(step)
		}
	end
}

aspect class IwStub{
	method explore(currentStep:IwStep) is do
		step:=currentStep
		//stle:Single again
		var staticPluginBinding:IwPluginBinding init pluginBindings.one 
		staticPluginBinding.inBindings.each{inBinding|inBinding.pluginStartPoint.step_DeepFirstSearch(step)}
	end
}

