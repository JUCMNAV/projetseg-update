package oneurn;

require kermeta
require "platform:/resource/aoUrnToRam/metamodel/oneurn.ecore"
require "platform:/resource/aoUrnToRam/metamodel/intermediateWorkflow.ecore"

using kermeta::standard
using oneurn::urncore
using intermediateWorkflow

package urn{
	aspect class URNspec{
		reference iwModel: IwModel
		reference _iwWithoutConcern:IwConcern
		
		property readonly ucmMaps : seq UCMmap[0..*]
		getter is do
			//stle: DRY
			result:= urndef.specDiagrams.select{specDiagram|specDiagram.isInstanceOf(UCMmap)}
							            .collect{specDiagram|specDiagram.asType(UCMmap)}
		end
		
		property readonly concerns : oset Concern[0..*]
		getter is do
			result:= urndef.concerns
		end
		
		property readonly iwWithoutConcern:IwConcern
		getter is do
			buildIwWithoutConcernOnDemand			
			result:=_iwWithoutConcern
		end
		
		operation buildIwWithoutConcernOnDemand() is do
			if(_iwWithoutConcern.isVoid) then
				_iwWithoutConcern:=IwConcern.new
				_iwWithoutConcern.name:="WithoutConcern"
			end
		end
	}
}

package urncore{
	aspect class Concern{
		reference _iwConcern:IwConcern
		
		property readonly iwConcern:IwConcern
		getter is do
			buildIwConcernOnDemand
			result:=_iwConcern
		end
		
		operation buildIwConcernOnDemand() is do
			if(_iwConcern.isVoid) then
				_iwConcern:=IwConcern.new
				_iwConcern.name:=nameOrPrefixId("Concern")
			end
		end
	}
	
	aspect class URNmodelElement{
		operation nameOrPrefixId(prefix:String):String is do
			if(name.isVoid or name=="") then 
				result:=prefix+"_"+id
			else
				result:=name
			end
		end
	}
}


package ucm{
package map{
	aspect class Stub {
		reference iwStub: IwStub
		
		method iwEquivalentNode():IwNode is do
			result:=iwStub
		end
	}
	
	aspect class PluginBinding {
		reference iwPluginBinding:IwPluginBinding
	}
	
	aspect class InBinding {
		reference iwInBinding:IwInBinding
	}
	
	aspect class OutBinding {
		reference iwOutBinding:IwOutBinding
	}

	aspect class UCMmap{
		reference iwWorkflow: IwWorkflow
		
		property readonly pathNodes : seq PathNode[0..*]
		getter is do
			//stle: DRY
			//stle: refactor for reuse
			result:=nodes.select{node|node.isInstanceOf(PathNode)}
				 .collect{node|node.asType(PathNode)}
		end

		property readonly startPoints : seq StartPoint[0..*]
		getter is do
			//stle: DRY
			//stle: refactor for reuse
			result:=nodes.select{node|node.isInstanceOf(StartPoint)}
				 .collect{node|node.asType(StartPoint)}
		end
	}
	
	aspect class PathNode {
		reference iwOutput: IwOutput
		reference iwInput: 	IwInput
		reference _iwNodes: oset IwNode[0..3] attribute _isIwNodesCached:Boolean
		
		property readonly iwNodes_ReadOnly: IwNode[0..3]
		getter is do
			if(_isIwNodesCached!=true) then
				initIwNodes
				_isIwNodesCached:=true
			end
			result:=_iwNodes.asOrderedSet //return a copy(enforce read-only)
		end
		
		operation uncacheIwNodes() is do 
			_isIwNodesCached:=false 
		end
	
		operation initIwNodes() is do
			if(IsOutputInputBefore) then
				CollectionExt_AddOptional(_iwNodes,iwOutput)
				CollectionExt_AddOptional(_iwNodes,iwInput)
				CollectionExt_AddOptional(_iwNodes,iwEquivalentNode)
			else
				CollectionExt_AddOptional(_iwNodes,iwEquivalentNode)
				CollectionExt_AddOptional(_iwNodes,iwOutput)
				CollectionExt_AddOptional(_iwNodes,iwInput)
			end
		end
		
		property readonly iwEntryNode: IwNode
		getter is do
			result:=iwNodes_ReadOnly.first
		end
		
		property readonly iwExitNode: IwNode
		getter is do
			result:=iwNodes_ReadOnly.last
		end
		
		//virtual
		operation IsOutputInputBefore():Boolean is do
			result:=true
		end
		
		//virtual
		operation iwEquivalentNode():IwNode is do
			result:=void
		end
		
		property readonly inOutExpression : InOutExpression
		getter is do
			var ramMetadata:Metadata init getRamMetadata()
			var inOutExpression:InOutExpression init InOutExpression.new
			inOutExpression.construct(if ramMetadata.isVoid then "" else ramMetadata.~value end)
			result:=inOutExpression
		end
		
		operation getRamMetadata():Metadata is do
			result:= metadata.select{n|n.name.toLowerCase()=="ram"}.one()
		end
		
		//stle: reuse static
		operation CollectionExt_AddOptional<T>(collection:Collection<T>, element:T) is do
			if(element.isVoid==false) then
				collection.add(element)
			end
		end
	}
	
	aspect class NodeConnection{
		reference iwNodeConnection: IwNodeConnection
		
		property readonly conditionLabel: String
		getter is do
			if(condition.isVoid==false) then
				result:=condition.label
			else
				result:=void
			end
		end
		
		property readonly iwSingleTarget : IwNode
		getter is do
			if(target.asType(PathNode).iwNodes_ReadOnly.isEmpty==false) then
				result:=target.asType(PathNode).iwEntryNode
			else
			    //target has no iwNodes implies target has always has a single succ
				//stle: single again
				result:=target.succ.one.asType(NodeConnection).iwSingleTarget
			end
		end
		
		//stle: test later
		property readonly iwSinglePredNodeConnection : IwNodeConnection
		getter is do
			if(iwNodeConnection.isVoid==false) then
				result:=iwNodeConnection
			else
			    //source has no iwNodeConnection implies a single IwNodeConnection exists before
				//stle: single again
				result:=source.pred.one.asType(NodeConnection).iwSinglePredNodeConnection
			end
		end
	}
	
	aspect class RespRef {
		reference iwCustomizableNode:IwCustomizableNode
		
		method iwEquivalentNode():IwNode is do
			result:=iwCustomizableNode
		end
	
		property readonly isSystemComponentRef : Boolean 
		getter is do
			result:=true
			var component:Component
			if(contRef.isVoid==false) then
				component?=contRef.contDef
				if(component.isVoid==false) then
					result:=(component.kind==ComponentKind.Actor)==false
				end
			end			
		end	
	
		method getRamMetadata():Metadata is do
			result:= respDef.metadata.select{n|n.name.toLowerCase()=="ram"}.one()
		end
	}
	
	aspect class StartPoint {
		reference iwStartPoint:IwStartPoint
		
		method iwEquivalentNode():IwNode is do
			result:=iwStartPoint
		end
		
		method IsOutputInputBefore():Boolean is do
			result:=false
		end
	}
	
	aspect class EndPoint {
		reference iwEndPoint:IwEndPoint
		
		method iwEquivalentNode():IwNode is do
			result:=iwEndPoint
		end
	}
	
	aspect class OrFork {
		reference iwOrFork:IwOrFork
		
		method iwEquivalentNode():IwNode is do
			result:=iwOrFork
		end
	}
	
	
	class InOutExpression
	{
		attribute out:String
		attribute in:String
		attribute outKeyword:String
		attribute inKeyword:String
		
		property readonly hasOut : Boolean 
		getter is do
			result := not out.isVoid
		end
			
		property readonly hasIn : Boolean 
		getter is do
			result := not in.isVoid
		end	
	
		operation construct(expression:String) is do
			outKeyword:="out "
			inKeyword:="in "
		
		//stle: need validation: RegEx would be better
			if(expression.toLowerCase().indexOf(outKeyword)==0) then
				expression:=expression.substring(outKeyword.size(), expression.size())		
				var index:Integer init expression.indexOf(" ")	
						
				if(index==-1) then
					out:=expression
					expression:=""			
				else
					out:=expression.substring(0, index)
					expression:=expression.substring(index+1, expression.size())				
				end
			end	
			if(expression.toLowerCase().indexOf(inKeyword)==0) then
				in:=expression.substring(inKeyword.size(), expression.size())
			end
			
		end
	} 
}	
}