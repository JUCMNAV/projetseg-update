package oneurn;

require "platform:/resource/aoUrnToRam/src/aoUrnToIw/Structural.kmt"

using kermeta::standard
using oneurn::urncore
using intermediateWorkflow

package urn{

	aspect class URNspec{
		operation link() is do
			ucmMaps.each{ucmMap|ucmMap.link(self)}
		end
		
		operation getIwConcern(concern:Concern):IwConcern is do
			if(concern.isVoid) then
				result:=iwWithoutConcern
			else
				result:=concern.iwConcern
			end
		end
		
		operation addIwWorflowRefact(concern:Concern,iwWorkflow:IwWorkflow) is do
			var iwConcern:IwConcern init getIwConcern(concern)

			if(iwModel.concerns.contains(iwConcern)==false)then
				iwModel.concerns.add(iwConcern)
			end
			iwConcern.workflows.add(iwWorkflow)
		end
	}
}	

package ucm{
package map{

	aspect class UCMmap{
		operation link(urnSpec:URNspec) is do
			urnSpec.addIwWorflowRefact(concern,iwWorkflow)
			linkChildren
		end
		
		operation linkChildren() is do
			pathNodes.each{pathNode|pathNode.link}
			
			addNodes
			addStartPoints
		end

		operation addNodes() is do
			pathNodes.each{pathNode|
				iwWorkflow.nodes.addAll(pathNode.iwNodes_ReadOnly)
			}
		end
		
		operation addStartPoints() is do
			iwWorkflow.startPoints.addAll(
				startPoints.collect{startPoint|startPoint.iwStartPoint}
			)	
		end
	}
	
	aspect class PathNode {
		operation link() is do
			linkSuccs
			linkInternal
		end

		operation linkInternal() is do
			var numOfInternalLinks:Integer init iwNodes_ReadOnly.size-1 //-1 because last internal node has no outcoming internal link
			numOfInternalLinks.times{i|
				var connection:IwNodeConnection init IwNodeConnection.new
				connection.source:=iwNodes_ReadOnly.at(i)
				connection.target:=iwNodes_ReadOnly.at(i+1)
			}
		end
		
		operation linkSuccs() is do
			if(iwNodes_ReadOnly.isEmpty==false) then
				succ.each{nodeConnection|nodeConnection.asType(NodeConnection).link}
			end
		end
	}
	
	aspect class NodeConnection {
		operation link() is do
			iwNodeConnection.source:=source.asType(PathNode).iwExitNode
			iwNodeConnection.target:=iwSingleTarget
		end
	}
	
	aspect class Stub {
		method link() is do
			super
			bindings.each{pluginBinding|pluginBinding.link}
		end
		
		operation addIwPluginBinding(iwPluginBinding:IwPluginBinding) is do
			iwStub.pluginBindings.add(iwPluginBinding)
		end
	}

	aspect class PluginBinding {
		operation link() is do
			in.each{inBinding|inBinding.link}
			out.each{outBinding|outBinding.link}
			
			linkStub
		end

		operation linkStub() is do
			stub.addIwPluginBinding(iwPluginBinding)
		end
		
		operation addIwInBinding(iwInBinding:IwInBinding) is do
			iwPluginBinding.inBindings.add(iwInBinding)
		end

		operation addIwOutBinding(iwOutBinding:IwOutBinding) is do
			iwPluginBinding.outBindings.add(iwOutBinding)
		end
	}
	
	aspect class InBinding {
		operation link() is do
			linkStartPoint
			linkStubEntry
			linkPluginBinding
		end

		operation linkPluginBinding() is do
			binding.addIwInBinding(iwInBinding)	
		end
		
		operation linkStartPoint() is do
			iwInBinding.pluginStartPoint:=startPoint.iwStartPoint	
		end
		
		operation linkStubEntry() is do
			iwInBinding.stubEntry:=stubEntry.iwSinglePredNodeConnection	
		end
	}

	aspect class OutBinding {
		operation link() is do
			linkEndPoint
			linkStubExit
			linkPluginBinding
		end
		
		operation linkPluginBinding() is do
			binding.addIwOutBinding(iwOutBinding)	
		end
		
		operation linkEndPoint() is do
			iwOutBinding.pluginEndPoint:=endPoint.iwEndPoint
		end
		
		operation linkStubExit() is do
			iwOutBinding.stubExit:=stubExit.iwNodeConnection	
		end
		
	}
}
}

