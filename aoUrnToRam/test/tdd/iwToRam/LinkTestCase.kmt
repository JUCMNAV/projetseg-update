package aoUrnToRam::Test;

require kermeta
require "platform:/resource/aoUrnToRam/test/tdd/iwToRam/IwTestFactory.kmt"
require "platform:/resource/aoUrnToRam/src/iwToRam/Build.kmt"
require "platform:/resource/aoUrnToRam/src/iwToRam/Link.kmt"

using kermeta::standard
using kermeta::kunit
using intermediateWorkflow
using ramstructural

class IwToRamLinkTestCase inherits TestCase
{
	attribute factory:IwTestFactory

	method setUp() is do
		factory:=IwTestFactory.new
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkMapping_None() is do
		var actual:IwStep init factory.createIwStep()

		actual.build()
		actual.link()
		
		assert(actual.ramReactiveWorkflowInstantiation.mappings.size==0)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkMapping_ManySameSourceModelElement() is do
		var actual:IwStep init factory.createIwStep()
		3.times{i|actual.nodes.add(factory.createIwInput())} 

		actual.build()
		actual.link()
		
		assert(actual.ramReactiveWorkflowInstantiation.mappings.size==1)
		var inputDataMapping:Mapping init actual.ramReactiveWorkflowInstantiation.mappings.one
		
		//stle: dry between test and impl 
		assertStringEqual("|InputData",inputDataMapping.sourceModelElement)
		assert(inputDataMapping.maps.size==3)

		actual.nodes.each{iwNode|
						assert(inputDataMapping.maps.exists{map|
															map.oid==iwNode.asType(IwInput).ramInputData.oid}
						)
		}
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkMapping_ManyDifferentSourceModelElement() is do
		var actual:IwStep init factory.createIwStep()
		var iwInput:IwInput init factory.createIwInput()
		var iwOutput:IwOutput init factory.createIwOutput()
		actual.nodes.add(iwInput)
		actual.nodes.add(iwOutput)
		
		actual.build()
		actual.link()
		
		assert(actual.ramReactiveWorkflowInstantiation.mappings.size==3)
		
		//stle: dry between test and impl
		var mappings:Mapping[0..*] init actual.ramReactiveWorkflowInstantiation.mappings  
		assertSingleMapping(
			mappings.select{mapping|mapping.sourceModelElement=="|InputData"}.one,
			iwInput.ramInputData)

		assertSingleMapping(
			mappings.select{mapping|mapping.sourceModelElement=="|CustomizableNode"}.one,
			iwOutput.ramCustomizableNode)

		assertSingleMapping(
			mappings.select{mapping|mapping.sourceModelElement=="OutputData"}.one,
			iwOutput.ramOutputData)
	end
	
	operation assertSingleMapping(mapping:Mapping,target:Class) is do
		assert(mapping.maps.size==1)
		assert(mapping.maps.one==target)
	end
	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkStep() is do
		var actual:IwStep init factory.createIwStep()
		actual.build()
		actual.link()
		
		assert(actual.ramStructuralView.instantiations.size==1)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkNoNodeFromStep() is do
		var actual:IwStep init factory.createIwStep()
		
		actual.build()
		actual.link()
		
		assert(actual.ramStructuralView.classes.size==0)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkOneNodeFromStep() is do
		var actual:IwStep init factory.createIwStep()
		actual.nodes.add(factory.createIwInput())
		
		actual.build()
		actual.link()
		
		assert(actual.ramStructuralView.classes.size==1)
	end


	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkManyNodeFromStep() is do
		var actual:IwStep init factory.createIwStep()
		actual.nodes.add(factory.createIwInput())
		2.times{i|actual.nodes.add(factory.createIwCustomizableNode())}
		actual.nodes.add(factory.createIwOutput())
		
		actual.build()
		actual.link()
		
		assert(actual.ramStructuralView.classes.size==1+1+1+2)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkIwModel_nSteps() is do
		//stle: need parametrizable tests
		var params:Integer[0..*] init OrderedSet<Integer>.new
		params.add(0)
		params.add(1)
		params.add(3)
		
		params.each{param|parametrizableTestLinkIwModel_nSteps(param)}
	end

	
	operation parametrizableTestLinkIwModel_nSteps(numOfSteps:Integer) is do
		var actual:IwModel init factory.createIwModel
		var concern:IwConcern init factory.createIwConcern
		actual.concerns.add(concern)
		numOfSteps.times{i| 
			var step:IwStep init factory.createIwStep
			step.nodes.add(factory.createIwCustomizableNode())
			concern.steps.add(step)
		}
		
		actual.build
		actual.link
		
		assert(actual.ramAspects.size==numOfSteps)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkIwModel_FilterOutStepWithoutAnyClasses() is do
		var actual:IwModel init factory.createIwModel
		var concern:IwConcern init factory.createIwConcern
		actual.concerns.add(concern)
		concern.steps.add(factory.createIwStep)

		actual.build
		actual.link
		
		assert(actual.ramAspects.size==0)
	end

	@feature "FeaTransformOrFork"
	operation testLinkIwFork() is do
		var actual:IwOrFork init factory.createIwOrFork
		var step:IwStep init factory.createIwStep()
		actual.step:=step
		factory.createIwNodeConnection(actual,factory.createIwCustomizableNode).conditionName:="theBranch1"
		factory.createIwNodeConnection(actual,factory.createIwCustomizableNode).conditionName:="theBranch2"
		factory.createIwNodeConnection(actual,factory.createIwCustomizableNode).conditionName:="theBranch3"
		step.build
		
		actual.link

		//properly linked
		assert(step.ramStructuralView.classes.asSet==actual.ramConditions)
		
		//stle: add .single to collection class
		assert(step.ramReactiveWorkflowInstantiation.mappings.size==1)
		var mapping:Mapping init step.ramReactiveWorkflowInstantiation.mappings.one
		
		//stle: not the right place for condition, step should have a property for each sourceModelElement, the add mapping should be tested in isolation
		assertStringEqual("Condition",mapping.sourceModelElement)
		assertSetOfBaseClasses_Equals_SetOfSubClasses(mapping.maps.asSet,actual.ramConditions)
	end


	operation testLinkIwPluginBinding() is do
		var step:IwStep init factory.createIwStep()
		var stub:IwStub init factory.createIwStub
		stub.step:=step
		var actual:IwPluginBinding init factory.createIwPluginBinding
		actual.stub:=stub

		step.build
		actual.link

		var expectedClasses:Set<Class> init Set<Class>.new
		expectedClasses.add(actual.ramCondition) 
		expectedClasses.add(actual.ramReplicationFactor)

		//properly linked
		assert(expectedClasses==step.ramStructuralView.classes.asSet)
		
		assert(step.ramReactiveWorkflowInstantiation.mappings.size==2)
		//stle: add .selectSingle
		var conditionMapping:Mapping init step.ramReactiveWorkflowInstantiation.mappings.select{mapping|mapping.sourceModelElement=="Condition"}.one
		assert(conditionMapping.isVoid==false)
		assertCollectionHasSingleElement(conditionMapping.maps,actual.ramCondition)

		//stle: add .selectSingle
		var replicationFactorMapping:Mapping init step.ramReactiveWorkflowInstantiation.mappings.select{mapping|mapping.sourceModelElement=="Condition"}.one
		assert(replicationFactorMapping.isVoid==false)
		assertCollectionHasSingleElement(replicationFactorMapping.maps,actual.ramReplicationFactor)
	end

	operation assertCollectionHasSingleElement<T>(collection:Collection<T>,singleElement:T) is do
		assertObjectEqual(1,collection.size)
		assert(collection.one==singleElement)
	end

	//stle: dry
	//stle: more verbrose on assertion
	operation assertIsNonVoidInstanceOf(expected:kermeta::language::structure::Class, actual:Object) is do
		assertWithMsg(actual.isVoid==false,"IsVoid-> expected:false actual:true")
		assertWithMsg(actual.isInstanceOf(expected),"IsInstanceOf-> expected:\""+expected.toString()+"\"actual:\""+actual.getMetaClass().toString()+"\"")
	end

	//stle: reusable
	operation assertSetOfBaseClasses_Equals_SetOfSubClasses<BaseType,SubType>(setOfBaseClasses:Set<BaseType>,setOfSubClasses:Set<SubType>) is do
		assert(setOfBaseClasses.size==setOfSubClasses.size)
		assert(setOfBaseClasses.containsAll(setOfSubClasses))
	end

	
	operation assertStringEqual(expected:String, actual:String) is do
		assertWithMsg(expected==actual,"StringEqual-> expected:\""+expected+"\"actual:\""+actual+"\"")
	end
	
	operation assertObjectEqual(expected:Object, actual:Object) is do
	//stle: check for void and type
		assertWithMsg(expected==actual,"ObjectEqual-> expected:\""+expected.toString+"\" actual:\""+actual.toString+"\"")
	end
	
}