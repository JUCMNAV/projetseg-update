package aoUrnToRam::Test;

require kermeta
require "platform:/resource/aoUrnToRam/metamodel/oneurn.ecore"

using kermeta::standard
using kermeta::utils
using kermeta::exceptions
using oneurn::urn
using oneurn::ucm::map
using oneurn::urncore

class AoUrnTestFactory
{
	reference components_PerName: Hashtable<String, Component>

	operation createComponentRef(name:String,kind:ComponentKind):ComponentRef is do
		result:=ComponentRef.new
		result.contDef:=getComponents(name,kind)
	end

	operation getComponents(name:String,kind:ComponentKind):Component is do
		if(components_PerName.isVoid) then
			components_PerName:=Hashtable<String, Component>.new
		end
		
		if(components_PerName.containsKey(name)==false) then
			var component:Component init Component.new
			component.name:=name
			component.kind:=kind
			components_PerName.put(name,component)
		end
		result:=components_PerName.getValue(name)
		if(result.kind!=kind) then
			//stle: proper exception
			raise Exception.new
		end
	end

	operation createEndPoint(name:String,ramExpression:String):EndPoint is do
		var pluginEndPoint:EndPoint init EndPoint.new
		pluginEndPoint.name:=optionalString(name)
		addRamMetadata(pluginEndPoint,ramExpression)
		result:=pluginEndPoint
	end
	
	operation createOrFork(name:String,ramExpression:String):OrFork is do
		var orFork:OrFork init OrFork.new
		orFork.name:=optionalString(name)
		addRamMetadata(orFork,ramExpression)
		result:=orFork
	end

	operation createOrJoin(ramExpression:String):OrJoin is do
		var orJoin:OrJoin init OrJoin.new
		addRamMetadata(orJoin,ramExpression)
		result:=orJoin
	end

	operation createStartPoint(ramExpression:String):StartPoint is do
		var startPoint:StartPoint init StartPoint.new
		addRamMetadata(startPoint,ramExpression)
		result:=startPoint
	end

	operation createRespRef(name:String,ramExpression:String):RespRef is do
		result:=createRespRefGeneric(name,ramExpression,false)
	end
	
	operation createRespRefGeneric(name:String,ramExpression:String,insideActor:Boolean):RespRef is do
		var respRef:RespRef init RespRef.new
		respRef.respDef:=createResponsibility(name,ramExpression)
		if(insideActor) then 
			respRef.contRef:=createComponentRef("theActor",ComponentKind.Actor)
		end
		result:=respRef
	end

	operation createResponsibility(name:String,ramExpression:String):Responsibility is do
		var responsibility:Responsibility init Responsibility.new
		responsibility.name:=optionalString(name)
		addRamMetadata(responsibility,ramExpression)
		result:=responsibility
	end
	
	operation addRamMetadata(element:URNmodelElement, ramExpression:String) is do
		if(ramExpression.isVoid==false) then
			var ramMetadata:Metadata init Metadata.new
			ramMetadata.name:="ram"
			ramMetadata.~value:=ramExpression
			element.metadata.add(ramMetadata)
		end
	end

	operation createConcern(name:String):Concern is do
		var concern:Concern init Concern.new
		concern.name:=optionalString(name)
		result:=concern 
	end
	
	operation createUcmMap(name:String):UCMmap is do
		var ucmMap:UCMmap init UCMmap.new
		ucmMap.name:=optionalString(name)
		result:=ucmMap 
	end

	operation createUrnSpec():URNspec is do
		var urnSpec:URNspec init URNspec.new
		urnSpec.urndef:=URNdefinition.new
		result:=urnSpec
	end

	operation createUrnSpecWithUcmMaps(numOfUcmMaps:Integer):URNspec is do
		var urnSpec:URNspec init createUrnSpec
		numOfUcmMaps.times{i|
			urnSpec.urndef.specDiagrams.add(createUcmMap(void))
		}
		result:=urnSpec
	end
	
	operation createStub():Stub is do
		result:=Stub.new
		result.name:="theStub"	
	end

	operation createPluginBinding():PluginBinding is do
		result:=PluginBinding.new
	end
	
	operation createInBinding():InBinding is do
		result:=InBinding.new
	end
	
	operation createOutBinding():OutBinding is do
		result:=OutBinding.new
	end
	
	operation createDefaultRespRef():RespRef is do
		result:=createRespRef("TheResponsibility",void)
	end
	
	operation createCondition(label:String):Condition is do
		result:=Condition.new
		result.label:=label
	end

	operation createNodeConnection():NodeConnection is do
		result:=NodeConnection.new
	end
	
	operation connectNodes(source:IURNNode,target:IURNNode):NodeConnection is do
		result:=createNodeConnection
		result.source:=source
		result.target:=target 
	end
	
	operation connectNodes_Condition(source:IURNNode,target:IURNNode,conditionLabel:String):NodeConnection is do
		result:=connectNodes(source,target)
		result.condition:=createCondition(conditionLabel)
	end
	

	//rethink about that, will still need to update factory method signature if numOfOptional param changes
	operation optionalString(val:String):String is do
		result:=if val.isVoid then "NotSet" else val end
	end
}
