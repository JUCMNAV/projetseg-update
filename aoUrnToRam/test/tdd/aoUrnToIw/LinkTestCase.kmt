package aoUrnToRam::Test;

require kermeta
require "platform:/resource/aoUrnToRam/test/tdd/aoUrnToIw/AoUrnTestFactory.kmt"
require "platform:/resource/aoUrnToRam/src/aoUrnToIw/Build.kmt"
require "platform:/resource/aoUrnToRam/src/aoUrnToIw/Link.kmt"

using kermeta::standard
using kermeta::kunit
using oneurn::urn
using oneurn::ucm::map
using oneurn::urncore
using intermediateWorkflow

using kermeta::language::structure

class AoUrnToIwLinkTestCase inherits TestCase
{
	attribute factory:AoUrnTestFactory

	method setUp() is do
		factory:=AoUrnTestFactory.new
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_NoResponsibility() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodes.size==0)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_OneResponsibility() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodes.size==1)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_ManyResponsibilities() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createRespRef(void, ""))
		ucmMap.nodes.add(factory.createRespRef(void, "in a"))
		ucmMap.nodes.add(factory.createRespRef(void, "out b"))
		ucmMap.nodes.add(factory.createRespRef(void, "out c in d"))
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodes.size==5)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkStartPoint_Internal() is do
		var actual:StartPoint init factory.createStartPoint("in theInput")
				
		actual.build
		actual.link
		
		assertStringEqual("theInput",actual.iwStartPoint.name)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkStartPoint_succPathNode() is do
		var actual:StartPoint init factory.createStartPoint(void)
		var pluginEndPoint:EndPoint init factory.createEndPoint("theEndPoint",void)
		factory.connectNodes(actual,pluginEndPoint)
				
		actual.build
		pluginEndPoint.build
		actual.link
		
		assertStringEqual("theEndPoint",actual.iwStartPoint.name)
	end
	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_OneStartPoint() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createStartPoint(void))
		ucmMap.nodes.add(factory.createRespRef(void, void))
		factory.connectNodes(ucmMap.nodes.at(0),ucmMap.nodes.at(1))
				
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.startPoints.size==1)
	end
	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_ManyStartPoint() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		//first start
		ucmMap.nodes.add(factory.createStartPoint(void))
		ucmMap.nodes.add(factory.createRespRef(void, void))
		factory.connectNodes(ucmMap.nodes.at(0),ucmMap.nodes.at(1))
		//second start
		ucmMap.nodes.add(factory.createStartPoint("out theOutput"))
				
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.startPoints.size==2)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_InternalOne() is do
		var actual:StartPoint init factory.createStartPoint("in b")

		actual.build
		actual.linkInternal

		assertObjectEqual(0,actual.iwInput.succs.size)
	end 	
	
	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_InternalTwoBefore() is do
		//stle: need to test after. wait for and-join
		var actual:EndPoint init factory.createEndPoint("theEndPoint","out a")

		actual.build
		actual.linkInternal

		assertSingleNodeConnection(actual.iwOutput,actual.iwEndPoint)			
	end
	
	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_InternalThreeBefore() is do
		var actual:EndPoint init factory.createEndPoint("theEndPoint","out a in b")

		actual.build
		actual.linkInternal

		assertSingleNodeConnection(actual.iwOutput,actual.iwInput)			
		assertSingleNodeConnection(actual.iwInput,actual.iwEndPoint)
	end 	
	 	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testNodeConnectionLink() is do
		var source:RespRef init factory.createDefaultRespRef
		var target:RespRef init factory.createDefaultRespRef
		var actual:NodeConnection init factory.connectNodes(source,target)

		source.build
		target.build
		actual.link
		
		assertSingleNodeConnection(source.iwExitNode,target.iwEntryNode)
	end 	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testNodeConnectionLink_ManyInternalNodesOnBothEnds() is do
		var source:RespRef init factory.createRespRef(void,"out a in b")
		var target:RespRef init factory.createRespRef(void,"out a in b")
		var actual:NodeConnection init factory.connectNodes(source,target)

		source.build
		target.build
		actual.link
		
		assertSingleNodeConnection(source.iwExitNode,target.iwEntryNode)
	end 	

	@feature "FeaHandleUntaggedResponsibilityInActor"
	operation testNodeConnectionLink_Transitive() is do
		var source:RespRef init factory.createDefaultRespRef
		var outsideSystem:RespRef init factory.createRespRefGeneric("theOneToSkip",void,true)
		var target:RespRef init factory.createDefaultRespRef
		var actual:NodeConnection init factory.connectNodes(source,outsideSystem)
		factory.connectNodes(outsideSystem,target)

		source.build
		outsideSystem.build
		target.build
		actual.link
		
		assertSingleNodeConnection(source.iwExitNode,target.iwEntryNode)
	end
	
	@feature "FeaTransformOrFork"
	operation testOrForkLink_ManySuccs() is do
		var actual:OrFork init factory.createOrFork("theOrFork",void)
		var target1:RespRef init factory.createRespRef("theTarget1",void)
		var target2:RespRef init factory.createRespRef("theTarget2",void)
		
		factory.connectNodes_Condition(actual,target1,"branch1")
		factory.connectNodes_Condition(actual,target2,"branch2")

		actual.build
		target1.build
		target2.build
		actual.link
		
		assertObjectEqual(2,actual.iwExitNode.succs.size)
		assertSingleConditionalPathNodeConnectionBetween(actual.iwExitNode,target1.iwEntryNode,"branch1")
		assertSingleConditionalPathNodeConnectionBetween(actual.iwExitNode,target2.iwEntryNode,"branch2")
	end

	@feature "FeaNamingofRAMConcern"
	operation testLinkUcmMap_OneWithConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(1)
		var concern:Concern init factory.createConcern("theConcern")
		var ucmMap:UCMmap init urnSpec.ucmMaps.one
		ucmMap.concern:=concern

		urnSpec.build
		urnSpec.link
		
		assert(urnSpec.iwModel.concerns.size==1)
		assert(urnSpec.iwModel.concerns.contains(concern.iwConcern))

		assert(concern.iwConcern.workflows.size==1)
		assert(concern.iwConcern.workflows.contains(ucmMap.iwWorkflow))
	end

	@feature "FeaNamingofRAMConcern"
	operation testLinkUcmMap_ZeroWithoutConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(0)

		urnSpec.build
		urnSpec.link
		
		assert(urnSpec.iwModel.concerns.size==0)
	end

	@feature "FeaNamingofRAMConcern"
	operation testLinkUcmMap_OneWithoutConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(1)
		var ucmMap:UCMmap init urnSpec.ucmMaps.one

		urnSpec.build
		urnSpec.link
		
		assert(urnSpec.iwModel.concerns.size==1)
		assert(urnSpec.iwModel.concerns.contains(urnSpec.iwWithoutConcern))

		assert(urnSpec.iwWithoutConcern.workflows.size==1)
		assert(urnSpec.iwWithoutConcern.workflows.contains(ucmMap.iwWorkflow))
	end
	
	
	//stle: what to do with the 0..many repetition?
	operation testLinkUcmMap_ManyWithoutConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(2)
		var ucmMapA:UCMmap init urnSpec.ucmMaps.at(0)
		var ucmMapB:UCMmap init urnSpec.ucmMaps.at(1)

		urnSpec.build
		urnSpec.link
		
		assert(urnSpec.iwModel.concerns.size==1)
		assert(urnSpec.iwModel.concerns.contains(urnSpec.iwWithoutConcern))

		assert(urnSpec.iwWithoutConcern.workflows.size==2)
		assert(urnSpec.iwWithoutConcern.workflows.contains(ucmMapA.iwWorkflow))
		assert(urnSpec.iwWithoutConcern.workflows.contains(ucmMapB.iwWorkflow))
	end
	
	operation testPluginBindingLink_Stub() is do
		var stub:Stub init factory.createStub
		var actual:PluginBinding init factory.createPluginBinding
		actual.stub:=stub

		stub.build
		actual.linkStub
		
		assertCollectionHasSingleElement(stub.iwStub.pluginBindings,actual.iwPluginBinding)
	end

	operation testInBindingLink_PluginBinding() is do
		var pluginBinding:PluginBinding init factory.createPluginBinding
		var actual:InBinding init factory.createInBinding
		actual.binding:=pluginBinding

		pluginBinding.build
		actual.linkPluginBinding
		
		assertCollectionHasSingleElement(pluginBinding.iwPluginBinding.inBindings,actual.iwInBinding)
	end
	
	operation testInBindingLink_StartPoint() is do
		var startPoint:StartPoint init factory.createStartPoint("in theInput")
		var actual:InBinding init factory.createInBinding
		actual.startPoint:=startPoint

		startPoint.build
		actual.build
		actual.linkStartPoint

		assert(startPoint.iwStartPoint==actual.iwInBinding.pluginStartPoint)
	end
	
	operation testInBindingLink_StubEntry() is do
		var stubEntry:NodeConnection init factory.createNodeConnection
		var actual:InBinding init factory.createInBinding
		actual.stubEntry:=stubEntry

		actual.build
		actual.linkStubEntry

		assert(stubEntry.iwNodeConnection==actual.iwInBinding.stubEntry)
	end
	
	operation testOutBindingLink_PluginBinding() is do
		//stle:dry
		var pluginBinding:PluginBinding init factory.createPluginBinding
		var actual:OutBinding init factory.createOutBinding
		actual.binding:=pluginBinding

		pluginBinding.build
		actual.linkPluginBinding
		
		assertCollectionHasSingleElement(pluginBinding.iwPluginBinding.outBindings,actual.iwOutBinding)
	end
	
	operation testOutBindingLink_EndPoint() is do
		var pluginEndPoint:EndPoint init factory.createEndPoint("theEndPoint",void)
		var actual:OutBinding init factory.createOutBinding
		actual.endPoint:=pluginEndPoint

		pluginEndPoint.build
		actual.build
		actual.linkEndPoint

		assert(pluginEndPoint.iwExitNode==actual.iwOutBinding.pluginEndPoint)
	end
	
	operation testOutBindingLink_StubExit() is do
		var stubExit:NodeConnection init factory.createNodeConnection
		var actual:OutBinding init factory.createOutBinding
		actual.stubExit:=stubExit

		actual.build
		actual.linkStubExit

		assert(stubExit.iwNodeConnection==actual.iwOutBinding.stubExit)
	end
	
	
	
	
	
	
	
	
	
	operation assertSingleNodeConnection(source:IwNode, target:IwNode) is do
		assertObjectEqual(1,source.succs.size)
		assertExistsNodeConnection(source,target) 
	end
	
	operation assertExistsNodeConnection(source:IwNode, target:IwNode) is do
		assert(source.succs.exists{succ|succ.target==target}) 
	end
	
	operation assertSingleConditionalPathNodeConnectionBetween(source:IwNode, target:IwNode, conditionName:String) is do
		var numOfConnection:Integer init source.succs.select{nodeConnection|
										nodeConnection.target==target and nodeConnection.conditionName==conditionName}.size
		assertObjectEqual(1,numOfConnection) 
	end
	
	operation assertCollectionHasSingleElement<T>(collection:Collection<T>,singleElement:T) is do
		assertObjectEqual(1,collection.size)
		assert(collection.one==singleElement)
	end

	//stle: dry
	//stle: more verbrose on assertion
	operation assertIsNonVoidInstanceOf(expected:kermeta::language::structure::Class, actual:Object) is do
		assertWithMsg(actual.isVoid==false,"IsVoid-> expected:false actual:true")
		assertWithMsg(actual.isInstanceOf(expected),"IsInstanceOf-> expected:\""+expected.toString()+"\"actual:\""+actual.getMetaClass().toString()+"\"")
	end


	operation assertObjectEqual(expected:Object, actual:Object) is do
	//stle: check for void and type
		assertWithMsg(expected==actual,"ObjectEqual-> expected:\""+expected.toString+"\" actual:\""+actual.toString+"\"")
	end

	
	operation assertStringEqual(expected:String, actual:String) is do
		assertWithMsg(expected==actual,"StringEqual-> expected:\""+expected+"\"actual:\""+actual+"\"")
	end
	
}