package aoUrnToRam::Test;

require kermeta
require "platform:/resource/aoUrnToRam/test/tdd/aoUrnToIw/AoUrnTestFactory.kmt"
require "platform:/resource/aoUrnToRam/src/aoUrnToIw/Build.kmt"
require "platform:/resource/aoUrnToRam/src/aoUrnToIw/Link.kmt"

using kermeta::standard
using kermeta::kunit
using oneurn::urn
using oneurn::ucm::map
using oneurn::urncore
using intermediateWorkflow

using kermeta::language::structure

class AoUrnToIwLinkTestCase inherits TestCase
{
	attribute factory:AoUrnTestFactory

	method setUp() is do
		factory:=AoUrnTestFactory.new
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_NoResponsibility() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodes.size==0)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_OneResponsibility() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodes.size==1)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_ManyResponsibilities() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createRespRef(void, ""))
		ucmMap.nodes.add(factory.createRespRef(void, "in a"))
		ucmMap.nodes.add(factory.createRespRef(void, "out b"))
		ucmMap.nodes.add(factory.createRespRef(void, "out c in d"))
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodes.size==5)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkStartPoint_Internal() is do
		var actual:StartPoint init factory.createStartPoint("in theInput")
				
		actual.build
		actual.link
		
		assertStringEqual("theInput",actual.iwStartNode.name)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkStartPoint_succPathNode() is do
		var actual:StartPoint init factory.createStartPoint(void)
		var endPoint:EndPoint init factory.createEndPoint("theEndPoint",void)
		factory.createNodeConnection(actual,endPoint)
				
		actual.build
		endPoint.build
		actual.link
		
		assertStringEqual("theEndPoint",actual.iwStartNode.name)
	end
	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_OneStartPoint() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createStartPoint(void))
		ucmMap.nodes.add(factory.createRespRef(void, void))
		factory.createNodeConnection(ucmMap.nodes.at(0),ucmMap.nodes.at(1))
				
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.startNodes.size==1)
	end
	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_ManyStartPoint() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		//first start
		ucmMap.nodes.add(factory.createStartPoint(void))
		ucmMap.nodes.add(factory.createRespRef(void, void))
		factory.createNodeConnection(ucmMap.nodes.at(0),ucmMap.nodes.at(1))
		//second start
		ucmMap.nodes.add(factory.createStartPoint("out theOutput"))
				
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.startNodes.size==2)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_NoNodeConnection() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.nodes.add(factory.createRespRef(void, void))

		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodeConnections.size==0)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_OneNodeConnection() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.connections.add(factory.createNodeConnection(ucmMap.nodes.at(0),ucmMap.nodes.at(1)))
		
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodeConnections.size==1)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkUcmMap_ManyNodeConnection() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)

		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.nodes.add(factory.createRespRef(void, "out c in d"))
		ucmMap.nodes.add(factory.createRespRef(void, void))
		ucmMap.connections.add(factory.createNodeConnection(ucmMap.nodes.at(0),ucmMap.nodes.at(1)))
		ucmMap.connections.add(factory.createNodeConnection(ucmMap.nodes.at(1),ucmMap.nodes.at(2)))
		
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodeConnections.size==3)
	end
	
	//stle: rename tests	
	//stle: only on customer
	operation testPathNodeLink_ZeroToZero() is do
	end 	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_ZeroToOne() is do
		var source:StartPoint init factory.createStartPoint(void)
		var target:RespRef init factory.createRespRef("theTarget",void)
		factory.createNodeConnection(source,target)

		source.build
		target.build
		source.link
		
		assert(target.iwNodes.first.preds.size==0)
	end 	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_OneToZero() is do
		var source:EndPoint init factory.createEndPoint(void,void)
		source.build
		source.link
		
		assert(source.iwNodes.last.succs.size==0)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_OneToOne() is do
		var source:RespRef init factory.createRespRef("theSource",void)
		var target:RespRef init factory.createRespRef("theTarget",void)
		factory.createNodeConnection(source,target)

		source.build
		target.build
		source.link
		
		assertPathNodeConnection(source,target)
	end 	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testPathNodeLink_ManyToMany() is do
		var source:RespRef init factory.createRespRef(void,"out a in b")
		var target:RespRef init factory.createRespRef(void,"out c in d")
		factory.createNodeConnection(source,target)

		source.build
		target.build
		source.link

		assertPathNodeConnection(source,target)
	end

	@feature "FeaHandleUntaggedResponsibilityInActor"
	operation testPathNodeLink_Transitive_Link() is do
		var source:StartPoint init factory.createStartPoint("in theStart")
		var outsideSystem:RespRef init factory.createRespRefGeneric("theOneToSkip",void,false)
		var target:RespRef init factory.createRespRef("theTarget",void)
		factory.createNodeConnection(source,outsideSystem)
		factory.createNodeConnection(outsideSystem,target)
	
		source.build
		outsideSystem.build
		target.build
		source.link
		
		assertPathNodeConnection(source,target)
	end

	@feature "FeaHandleUntaggedResponsibilityInActor"
	operation testLinkUcmMap_OneTransitiveConnection() is do
		var ucmMap:UCMmap init factory.createUcmMap(void)
		ucmMap.nodes.add(factory.createStartPoint("in theStart"))
		ucmMap.nodes.add(factory.createRespRefGeneric("theOneToSkip",void,false))
		ucmMap.nodes.add(factory.createRespRef("theTarget",void))
		factory.createNodeConnection(ucmMap.nodes.at(0),ucmMap.nodes.at(1))
		factory.createNodeConnection(ucmMap.nodes.at(1),ucmMap.nodes.at(2))
		
		ucmMap.build
		ucmMap.linkChildren
		
		assert(ucmMap.iwWorkflow.nodeConnections.size==1)
	end
	
	 	

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkOutInPathNode() is do
		var respRef:RespRef init factory.createRespRef("theRespRef","out theSource in theTarget")

		respRef.build
		respRef.link

		assertInternalNodeConnection(respRef,0,1)
	end

	@feature "FeaTransformStartPointResponsibilityEndPoint"
	operation testLinkOutInEndPoint() is do
		var actual:EndPoint init factory.createEndPoint("theEndPoint","out theOutputName in theInputName")

		actual.build
		actual.link

		assertInternalNodeConnection(actual,0,1)
		assertInternalNodeConnection(actual,1,2)
	end

	@feature "FeaTransformOrFork"
	operation testOrForkLink_2Branchs() is do
		var source:OrFork init factory.createOrFork("theOrFork",void)
		var targetA:RespRef init factory.createRespRef("theTargetA",void)
		var targetB:RespRef init factory.createRespRef("theTargetB",void)
		factory.createConditionalNodeConnection(source,targetA,"branchA")
		factory.createConditionalNodeConnection(source,targetB,"branchB")

		source.build
		targetA.build
		targetB.build
		source.link
		
		assertObjectEqual(2,source.iwNodes.last.succs.size)
		assertSingleConditionalPathNodeConnectionBetween(source,targetA,"branchA")
		assertSingleConditionalPathNodeConnectionBetween(source,targetB,"branchB")
	end

	@feature "FeaTransformOrFork"
	operation testOrForkLink_ManyBranchs() is do
		var source:OrFork init factory.createOrFork("theOrFork",void)
		var targetA:RespRef init factory.createRespRef("theTargetA",void)
		var targetB:RespRef init factory.createRespRef("theTargetB",void)
		var targetC:RespRef init factory.createRespRef("theTargetC",void)
		factory.createConditionalNodeConnection(source,targetA,"branchA")
		factory.createConditionalNodeConnection(source,targetB,"branchB")
		factory.createConditionalNodeConnection(source,targetC,"branchC")

		source.build
		targetA.build
		targetB.build
		targetC.build
		source.link
		
		assertObjectEqual(3,source.iwNodes.last.succs.size)
		assertSingleConditionalPathNodeConnectionBetween(source,targetA,"branchA")
		assertSingleConditionalPathNodeConnectionBetween(source,targetB,"branchB")
		assertSingleConditionalPathNodeConnectionBetween(source,targetC,"branchC")
	end 	

	@feature "FeaTransformOrJoin"
	operation testOrJoinLink_2Branchs() is do
		var sourceA:RespRef init factory.createRespRef("theSourceA",void)
		var sourceB:RespRef init factory.createRespRef("theSourceB",void)
		var target:OrJoin init factory.createOrJoin("in joinInput")
		
		factory.createNodeConnection(sourceA,target)
		factory.createNodeConnection(sourceB,target)
		
		sourceA.build
		sourceB.build
		target.build
		sourceA.link
		sourceB.link
		//stle: OrJoin link like any other node, will be tested when testing liskov by base test class. For now it is assumed to be true.
		
		assertObjectEqual(2,target.iwNodes.first.preds.size)
		assertPathNodeConnection(sourceA,target)
		assertPathNodeConnection(sourceB,target)
	end 	

	@feature "FeaTransformOrJoin"
	operation testOrJoinLink_ManyBranchs() is do
		var sourceA:RespRef init factory.createRespRef("theSourceA",void)
		var sourceB:RespRef init factory.createRespRef("theSourceB",void)
		var sourceC:RespRef init factory.createRespRef("theSourceC",void)
		var target:OrJoin init factory.createOrJoin("in joinInput")
		
		factory.createNodeConnection(sourceA,target)
		factory.createNodeConnection(sourceB,target)
		factory.createNodeConnection(sourceC,target)
		
		sourceA.build
		sourceB.build
		sourceC.build
		target.build
		sourceA.link
		sourceB.link
		sourceC.link
		
		assertObjectEqual(3,target.iwNodes.first.preds.size)
		assertPathNodeConnection(sourceA,target)
		assertPathNodeConnection(sourceB,target)
		assertPathNodeConnection(sourceC,target)
	end 	



	operation assertInternalNodeConnection(pathNode:PathNode, source:Integer, target:Integer) is do
		assertNodeConnection(pathNode.iwNodes.at(source),
							 pathNode.iwNodes.at(target))
	end
	
	operation assertPathNodeConnection(source:PathNode, target:PathNode) is do
		assertNodeConnection(source.iwNodes.last,
							 target.iwNodes.first)
	end
	
	operation assertNodeConnection(source:IwNode, target:IwNode) is do
		assertObjectEqual(1,source.succs.size)
		assert(source.succs.exists{succ|succ.target.oid==target.oid}) 
	end
	
	operation assertSingleConditionalPathNodeConnectionBetween(source:PathNode, target:PathNode, conditionName:String) is do
		var sourceIwNode:IwNode init source.iwNodes.last
		var targetIwNode:IwNode init target.iwNodes.first
		
		var numOfConnection:Integer init sourceIwNode.succs.select{succ|
										succ.target.oid==targetIwNode.oid and succ.conditionName==conditionName}.size
		assertObjectEqual(1,numOfConnection) 
	end


	operation testLinkUcmMap_OneWithConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(1)
		var concern:Concern init factory.createConcern("theConcern")
		var ucmMap:UCMmap init urnSpec.ucmMaps.one
		ucmMap.concern:=concern

		urnSpec.build
		urnSpec.linkChildren
		
		assert(urnSpec.iwModel.concerns.size==1)
		assert(urnSpec.iwModel.concerns.contains(concern.iwConcern))

		assert(concern.iwConcern.workflows.size==1)
		assert(concern.iwConcern.workflows.contains(ucmMap.iwWorkflow))
	end

	operation testLinkUcmMap_ZeroWithoutConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(0)

		urnSpec.build
		urnSpec.linkChildren
		
		assert(urnSpec.iwModel.concerns.size==0)
	end
	
	operation testLinkUcmMap_OneWithoutConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(1)
		var ucmMap:UCMmap init urnSpec.ucmMaps.one

		urnSpec.build
		urnSpec.linkChildren
		
		assert(urnSpec.iwModel.concerns.size==1)
		assert(urnSpec.iwModel.concerns.contains(urnSpec.iwWithoutConcern))

		assert(urnSpec.iwWithoutConcern.workflows.size==1)
		assert(urnSpec.iwWithoutConcern.workflows.contains(ucmMap.iwWorkflow))
	end
	
	
	//stle: what to do with the 0..many repetition?
	operation testLinkUcmMap_ManyWithoutConcern() is do
		var urnSpec:URNspec init factory.createUrnSpecWithUcmMaps(2)
		var ucmMapA:UCMmap init urnSpec.ucmMaps.at(0)
		var ucmMapB:UCMmap init urnSpec.ucmMaps.at(1)

		urnSpec.build
		urnSpec.linkChildren
		
		assert(urnSpec.iwModel.concerns.size==1)
		assert(urnSpec.iwModel.concerns.contains(urnSpec.iwWithoutConcern))

		assert(urnSpec.iwWithoutConcern.workflows.size==2)
		assert(urnSpec.iwWithoutConcern.workflows.contains(ucmMapA.iwWorkflow))
		assert(urnSpec.iwWithoutConcern.workflows.contains(ucmMapB.iwWorkflow))
	end
	
	

	//stle: dry
	//stle: more verbrose on assertion
	operation assertIsNonVoidInstanceOf(expected:kermeta::language::structure::Class, actual:Object) is do
		assertWithMsg(actual.isVoid==false,"IsVoid-> expected:false actual:true")
		assertWithMsg(actual.isInstanceOf(expected),"IsInstanceOf-> expected:\""+expected.toString()+"\"actual:\""+actual.getMetaClass().toString()+"\"")
	end


	operation assertObjectEqual(expected:Object, actual:Object) is do
	//stle: check for void and type
		assertWithMsg(expected==actual,"ObjectEqual-> expected:\""+expected.toString+"\" actual:\""+actual.toString+"\"")
	end

	
	operation assertStringEqual(expected:String, actual:String) is do
		assertWithMsg(expected==actual,"StringEqual-> expected:\""+expected+"\"actual:\""+actual+"\"")
	end
	
}